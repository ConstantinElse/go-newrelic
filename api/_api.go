/* 
 * No descripton provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package newrelic-api

import (
	"net/url"
	"time"
	"fmt"
	"strings"
)

type DefaultApi struct {
	Configuration Configuration
}

func NewDefaultApi() *DefaultApi {
	configuration := NewConfiguration()
	return &DefaultApi{
		Configuration: *configuration,
	}
}

func NewDefaultApiWithBasePath(basePath string) *DefaultApi {
	configuration := NewConfiguration()
	configuration.BasePath = basePath

	return &DefaultApi{
		Configuration: *configuration,
	}
}

/**
 * Create
 * &lt;p&gt;This API endpoint works with new Alerts on alerts.newrelic.com.&lt;/p&gt;  &lt;p&gt;It creates a channel associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#channels-create\&quot;&gt;creating notification channels&lt;/a&gt;.&lt;/p&gt;  &lt;p&gt;Channel type configuration options:&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;     &lt;p&gt;Email&lt;/p&gt;      &lt;p&gt;{&lt;/p&gt;      &lt;pre&gt;&lt;code&gt;\&quot;recipients\&quot; : \&quot;test@google.com\&quot;, \&quot;include_json_attachment\&quot; : true &lt;/code&gt;&lt;/pre&gt;      &lt;p&gt;}&lt;/p&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;p&gt;HipChat&lt;/p&gt;      &lt;p&gt;{&lt;/p&gt;      &lt;pre&gt;&lt;code&gt;\&quot;auth_token\&quot;: \&quot;abc123\&quot;, \&quot;room_id\&quot;: \&quot;google.com\&quot; &lt;/code&gt;&lt;/pre&gt;      &lt;p&gt;}&lt;/p&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;p&gt;OpsGenie&lt;/p&gt;      &lt;p&gt;{&lt;/p&gt;      &lt;pre&gt;&lt;code&gt;\&quot;api_key\&quot;: \&quot;abc123\&quot;, \&quot;teams\&quot;: \&quot;team1\&quot;, \&quot;tags\&quot;: \&quot;tag1\&quot;, \&quot;recipients\&quot;: \&quot;me@me.com\&quot; &lt;/code&gt;&lt;/pre&gt;      &lt;p&gt;}&lt;/p&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;p&gt;Slack&lt;/p&gt;      &lt;p&gt;{&lt;/p&gt;      &lt;pre&gt;&lt;code&gt;\&quot;url\&quot;: \&quot;http://test.com\&quot;, \&quot;channel\&quot;: \&quot;channel1\&quot; &lt;/code&gt;&lt;/pre&gt;      &lt;p&gt;}&lt;/p&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;p&gt;Campfire&lt;/p&gt;      &lt;p&gt;{&lt;/p&gt;      &lt;pre&gt;&lt;code&gt;\&quot;subdomain\&quot;: \&quot;mysubdomain\&quot;, \&quot;token\&quot;: \&quot;123abc\&quot;, \&quot;room\&quot;: \&quot;room1\&quot; &lt;/code&gt;&lt;/pre&gt;      &lt;p&gt;}&lt;/p&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;p&gt;Victorops&lt;/p&gt;      &lt;p&gt;{&lt;/p&gt;      &lt;pre&gt;&lt;code&gt;\&quot;key\&quot;: \&quot;mykey\&quot;, \&quot;route_key\&quot;: \&quot;theroute\&quot; &lt;/code&gt;&lt;/pre&gt;      &lt;p&gt;}&lt;/p&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;p&gt;PagerDuty&lt;/p&gt;      &lt;p&gt;{&lt;/p&gt;      &lt;pre&gt;&lt;code&gt;\&quot;service_key\&quot;: \&quot;myservicekey\&quot; &lt;/code&gt;&lt;/pre&gt;      &lt;p&gt;}&lt;/p&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;p&gt;Webhook (json)&lt;/p&gt;      &lt;p&gt;{&lt;/p&gt;      &lt;pre&gt;&lt;code&gt;\&quot;base_url\&quot;: \&quot;http://test.com\&quot;, \&quot;auth_username\&quot;: \&quot;username\&quot;, \&quot;auth_password\&quot;: \&quot;password\&quot;, \&quot;payload_type\&quot;: \&quot;application/json\&quot;, \&quot;payload\&quot;: {\&quot;account_id\&quot;: 1, \&quot;account_name\&quot;: \&quot;account name\&quot; }, \&quot;headers\&quot;: {\&quot;header1\&quot;: \&quot;test\&quot;, \&quot;header2\&quot;: \&quot;test\&quot;} &lt;/code&gt;&lt;/pre&gt;      &lt;p&gt;}&lt;/p&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;p&gt;Webhook (x-www-form-urlencoded)&lt;/p&gt;      &lt;p&gt;{&lt;/p&gt;      &lt;pre&gt;&lt;code&gt;\&quot;base_url\&quot;: \&quot;http://test.com\&quot;, \&quot;auth_username\&quot;: \&quot;username\&quot;, \&quot;auth_password\&quot;: \&quot;password\&quot;, \&quot;payload_type\&quot;: \&quot;application/x-www-form-urlencoded\&quot;, \&quot;payload\&quot;: {\&quot;account_id\&quot;: 1, \&quot;account_name\&quot;: \&quot;account name\&quot; }, \&quot;headers\&quot;: {\&quot;header1\&quot;: \&quot;test\&quot;, \&quot;header2\&quot;: \&quot;test\&quot;} &lt;/code&gt;&lt;/pre&gt;      &lt;p&gt;}&lt;/p&gt;   &lt;/li&gt; &lt;/ul&gt;  
 *
 * @param channel channel schema
 * @param policyIds Policy IDs to associate with channel
 * @return void
 */
func (a DefaultApi) Create(channel Channel, policyIds []Object) (*APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_channels.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range policyIds {
			queryParams.Add("policy_ids", value)
		}
	} else {
		queryParams.Add("policy_ids", a.Configuration.APIClient.ParameterToString(policyIds, collectionFormat))
	}
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &channel


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Create
 * &lt;p&gt;This API endpoint works with new Alerts on alerts.newrelic.com.&lt;/p&gt;  &lt;p&gt;This Alerts API endpoint creates a policy associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  &lt;p&gt;Rollup stategy options:&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;PER_POLICY&lt;/li&gt;   &lt;li&gt;PER_CONDITION&lt;/li&gt;   &lt;li&gt;PER_CONDITION_AND_TARGET&lt;/li&gt; &lt;/ul&gt;  &lt;p&gt;See our documentation for a discussion on using the REST API for &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#policies-create\&quot; target&#x3D;\&quot;_blank\&quot;&gt;creating new policies&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param policy Policy Schema
 * @return void
 */
func (a DefaultApi) Create_1(policy Policy) (*APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_policies.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &policy


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Create
 * &lt;p&gt;This API endpoint allows you to create Synthetics conditions for your alert policies.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#synthetics-conditions-create\&quot; target&#x3D;\&quot;_blank\&quot;&gt;creating Synthetic conditions&lt;/a&gt;.&lt;/p&gt;  &lt;p&gt;All fields are required except for “runbook_url”, “enabled” (defaults to false).&lt;/p&gt;  &lt;p&gt;&lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names#name\&quot; target&#x3D;\&quot;_blank\&quot;&gt;name&lt;/a&gt;: A title for your condition.&lt;/p&gt;  &lt;p&gt;&lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names#monitor_id\&quot; target&#x3D;\&quot;_blank\&quot;&gt;monitor_id&lt;/a&gt;: The GUID of the Synthetics monitor to alert on.&lt;/p&gt;  &lt;p&gt;&lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names#runbook_url\&quot; target&#x3D;\&quot;_blank\&quot;&gt;runbook_url&lt;/a&gt;: Runbook URL to display in notifications (optional).&lt;/p&gt;  &lt;p&gt;&lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names#enabled\&quot; target&#x3D;\&quot;_blank\&quot;&gt;enabled&lt;/a&gt;: The status of your condition (optional).&lt;/p&gt; 
 *
 * @param policyId Alerts policy ID
 * @param syntheticsCondition Condition schema
 * @return void
 */
func (a DefaultApi) Create_2(policyId Object, syntheticsCondition SyntheticsCondition) (*APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_synthetics_conditions/policies/{policy_id}.{format}"
	path = strings.Replace(path, "{"+"policy_id"+"}", fmt.Sprintf("%v", policyId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &syntheticsCondition


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Create
 * &lt;p&gt;This API endpoint creates a deployment record for a given application. Deployment records are created with the following attributes:&lt;/p&gt;  &lt;p&gt;Required:&lt;br /&gt;   - Application ID&lt;br /&gt;   - Revision, such as a git SHA&lt;br /&gt;&lt;/p&gt;  &lt;p&gt;Optional:&lt;br /&gt;   - Changelog &lt;br /&gt;   - Description &lt;br /&gt;   - User posting the deployment&lt;br /&gt;&lt;/p&gt;  &lt;p&gt;Note that the time of your deployment will be recorded as the current time in UTC.&lt;/p&gt; 
 *
 * @param applicationId Application ID
 * @param deployment Deployment schema
 * @return void
 */
func (a DefaultApi) Create_3(applicationId Object, deployment Deployment) (*APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/deployments.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &deployment


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Create
 * &lt;p&gt;This API endpoint allows you to create a standalone Browser Application.&lt;/p&gt; 
 *
 * @param browserApplication Browser Application Schema
 * @return void
 */
func (a DefaultApi) Create_4(browserApplication BrowserApplication) (*APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/browser_applications.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &browserApplication


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Create
 * &lt;p&gt;This API endpoint will create a new label with the provided category and name.&lt;/p&gt;  &lt;p&gt;Include the application and server IDs to which the label should be applied in the corresponding arrays. You may omit the “links” or “servers” arrays, if not needed.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on obtaining  &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/listing-your-app-id-metric-data-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;application&lt;/a&gt;  and  &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/server-examples-v2/list-your-server-id-metric-data-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;server&lt;/a&gt; IDs.&lt;/p&gt; 
 *
 * @param label Label schema
 * @return void
 */
func (a DefaultApi) Create_5(label Label) (*APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/labels.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &label


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Data
 * &lt;p&gt;This API endpoint returns a list of values for each of the requested metrics. The list of available metrics can be returned using the Metric Name API endpoint.&lt;/p&gt;  &lt;p&gt;Metric data can be filtered by a number of parameters, including multiple names and values, and by time range. Metric names and values will be matched intelligently in the background.&lt;/p&gt;  &lt;p&gt;You can also retrieve a summarized data point across the entire time range selected by using the summarize parameter.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;, &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/extracting-metric-data\&quot; target&#x3D;\&quot;_blank\&quot;&gt; time range&lt;/a&gt;  related considerations, and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param applicationId Application ID
 * @param hostId Application Host ID
 * @param names Retrieve specific metrics by name
 * @param values Retrieve specific metric values
 * @param from Retrieve metrics after this time
 * @param to Retrieve metrics before this time
 * @param period Period of timeslices in seconds
 * @param summarize Summarize the data
 * @param raw Return unformatted raw values
 * @return void
 */
func (a DefaultApi) Data(applicationId Object, hostId Object, names []Object, values []Object, from Object, to Object, period Object, summarize Object, raw Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/hosts/{host_id}/metrics/data.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)
	path = strings.Replace(path, "{"+"host_id"+"}", fmt.Sprintf("%v", hostId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range names {
			queryParams.Add("names", value)
		}
	} else {
		queryParams.Add("names", a.Configuration.APIClient.ParameterToString(names, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range values {
			queryParams.Add("values", value)
		}
	} else {
		queryParams.Add("values", a.Configuration.APIClient.ParameterToString(values, collectionFormat))
	}
			queryParams.Add("from", a.Configuration.APIClient.ParameterToString(from, ""))
			queryParams.Add("to", a.Configuration.APIClient.ParameterToString(to, ""))
			queryParams.Add("period", a.Configuration.APIClient.ParameterToString(period, ""))
			queryParams.Add("summarize", a.Configuration.APIClient.ParameterToString(summarize, ""))
			queryParams.Add("raw", a.Configuration.APIClient.ParameterToString(raw, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Data
 * &lt;p&gt;This API endpoint returns a list of values for each of the requested metrics. The list of available metrics can be returned using the Metric Name API endpoint.&lt;/p&gt;  &lt;p&gt;Metric data can be filtered by a number of parameters, including multiple names and values, and by time range. Metric names and values will be matched intelligently in the background.&lt;/p&gt;  &lt;p&gt;You can also retrieve a summarized data point across the entire time range selected by using the summarize parameter.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;, &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/extracting-metric-data\&quot; target&#x3D;\&quot;_blank\&quot;&gt; time range&lt;/a&gt;  related considerations, and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param applicationId Application ID
 * @param instanceId Application Instance ID
 * @param names Retrieve specific metrics by name
 * @param values Retrieve specific metric values
 * @param from Retrieve metrics after this time
 * @param to Retrieve metrics before this time
 * @param period Period of timeslices in seconds
 * @param summarize Summarize the data
 * @param raw Return unformatted raw values
 * @return void
 */
func (a DefaultApi) Data_6(applicationId Object, instanceId Object, names []Object, values []Object, from Object, to Object, period Object, summarize Object, raw Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/instances/{instance_id}/metrics/data.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)
	path = strings.Replace(path, "{"+"instance_id"+"}", fmt.Sprintf("%v", instanceId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range names {
			queryParams.Add("names", value)
		}
	} else {
		queryParams.Add("names", a.Configuration.APIClient.ParameterToString(names, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range values {
			queryParams.Add("values", value)
		}
	} else {
		queryParams.Add("values", a.Configuration.APIClient.ParameterToString(values, collectionFormat))
	}
			queryParams.Add("from", a.Configuration.APIClient.ParameterToString(from, ""))
			queryParams.Add("to", a.Configuration.APIClient.ParameterToString(to, ""))
			queryParams.Add("period", a.Configuration.APIClient.ParameterToString(period, ""))
			queryParams.Add("summarize", a.Configuration.APIClient.ParameterToString(summarize, ""))
			queryParams.Add("raw", a.Configuration.APIClient.ParameterToString(raw, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Data
 * &lt;p&gt;This API endpoint returns a list of values for each of the requested metrics. The list of available metrics can be returned using the Metric Name API endpoint.&lt;/p&gt;  &lt;p&gt;Metric data can be filtered by a number of parameters, including multiple names and values, and by time range. Metric names and values will be matched intelligently in the background.&lt;/p&gt;  &lt;p&gt;You can also retrieve a summarized data point across the entire time range selected by using the summarize parameter.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;, &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/extracting-metric-data\&quot; target&#x3D;\&quot;_blank\&quot;&gt; time range&lt;/a&gt;  related considerations, and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param componentId Component ID
 * @param names Retrieve specific metrics by name
 * @param values Retrieve specific metric values
 * @param from Retrieve metrics after this time
 * @param to Retrieve metrics before this time
 * @param period Period of timeslices in seconds
 * @param summarize Summarize the data
 * @param raw Return unformatted raw values
 * @return void
 */
func (a DefaultApi) Data_7(componentId Object, names []Object, values []Object, from Object, to Object, period Object, summarize Object, raw Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/components/{component_id}/metrics/data.{format}"
	path = strings.Replace(path, "{"+"component_id"+"}", fmt.Sprintf("%v", componentId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range names {
			queryParams.Add("names", value)
		}
	} else {
		queryParams.Add("names", a.Configuration.APIClient.ParameterToString(names, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range values {
			queryParams.Add("values", value)
		}
	} else {
		queryParams.Add("values", a.Configuration.APIClient.ParameterToString(values, collectionFormat))
	}
			queryParams.Add("from", a.Configuration.APIClient.ParameterToString(from, ""))
			queryParams.Add("to", a.Configuration.APIClient.ParameterToString(to, ""))
			queryParams.Add("period", a.Configuration.APIClient.ParameterToString(period, ""))
			queryParams.Add("summarize", a.Configuration.APIClient.ParameterToString(summarize, ""))
			queryParams.Add("raw", a.Configuration.APIClient.ParameterToString(raw, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Data
 * &lt;p&gt;This API endpoint returns a list of values for each of the requested metrics. The list of available metrics can be returned using the Metric Name API endpoint.&lt;/p&gt;  &lt;p&gt;Metric data can be filtered by a number of parameters, including multiple names and values, and by time range. Metric names and values will be matched intelligently in the background.&lt;/p&gt;  &lt;p&gt;You can also retrieve a summarized data point across the entire time range selected by using the summarize parameter.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;, &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/extracting-metric-data\&quot; target&#x3D;\&quot;_blank\&quot;&gt; time range&lt;/a&gt;  related considerations, and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param serverId Server ID
 * @param names Retrieve specific metrics by name
 * @param values Retrieve specific metric values
 * @param from Retrieve metrics after this time
 * @param to Retrieve metrics before this time
 * @param period Period of timeslices in seconds
 * @param summarize Summarize the data
 * @param raw Return unformatted raw values
 * @return void
 */
func (a DefaultApi) Data_8(serverId Object, names []Object, values []Object, from Object, to Object, period Object, summarize Object, raw Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/servers/{server_id}/metrics/data.{format}"
	path = strings.Replace(path, "{"+"server_id"+"}", fmt.Sprintf("%v", serverId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range names {
			queryParams.Add("names", value)
		}
	} else {
		queryParams.Add("names", a.Configuration.APIClient.ParameterToString(names, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range values {
			queryParams.Add("values", value)
		}
	} else {
		queryParams.Add("values", a.Configuration.APIClient.ParameterToString(values, collectionFormat))
	}
			queryParams.Add("from", a.Configuration.APIClient.ParameterToString(from, ""))
			queryParams.Add("to", a.Configuration.APIClient.ParameterToString(to, ""))
			queryParams.Add("period", a.Configuration.APIClient.ParameterToString(period, ""))
			queryParams.Add("summarize", a.Configuration.APIClient.ParameterToString(summarize, ""))
			queryParams.Add("raw", a.Configuration.APIClient.ParameterToString(raw, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete
 * &lt;p&gt;This API endpoint deletes Alerts notification channels.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#channels-delete\&quot;&gt;deleting notification channels&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param channelId Channel ID
 * @return void
 */
func (a DefaultApi) Delete(channelId Object) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_channels/{channel_id}.{format}"
	path = strings.Replace(path, "{"+"channel_id"+"}", fmt.Sprintf("%v", channelId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete
 * &lt;p&gt;This API endpoint deletes Alerts policies associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on using the REST API for &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#policies-delete\&quot; target&#x3D;\&quot;_blank\&quot;&gt;deleting policies&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param policyId Policy ID
 * @return void
 */
func (a DefaultApi) Delete_9(policyId Object) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_policies/{policy_id}.{format}"
	path = strings.Replace(path, "{"+"policy_id"+"}", fmt.Sprintf("%v", policyId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete
 * &lt;p&gt;This API endpoint deletes Alerts policy/channel associations.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#policy-channels-delete\&quot;&gt;deleting notification channels with policies&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param policyId Policy ID
 * @param channelId Channel ID
 * @return void
 */
func (a DefaultApi) Delete_10(policyId Object, channelId Object) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_policy_channels.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("policy_id", a.Configuration.APIClient.ParameterToString(policyId, ""))
			queryParams.Add("channel_id", a.Configuration.APIClient.ParameterToString(channelId, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete
 * &lt;p&gt;This API endpoint allows you to delete Synthetics conditions associated with your alert policy.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#synthetics-conditions-delete\&quot; target&#x3D;\&quot;_blank\&quot;&gt;deleting Synthetic conditions&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param conditionId Alerts condition ID
 * @return void
 */
func (a DefaultApi) Delete_11(conditionId Object) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_synthetics_conditions/{condition_id}.{format}"
	path = strings.Replace(path, "{"+"condition_id"+"}", fmt.Sprintf("%v", conditionId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete
 * &lt;p&gt;This API endpoint deletes the specified deployment record.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  
 *
 * @param applicationId Application ID
 * @param id Deployment ID
 * @return void
 */
func (a DefaultApi) Delete_12(applicationId Object, id Object) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/deployments/{id}.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete
 * &lt;p&gt;This API endpoint deletes an application and all of its reported data.&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: Only applications that have stopped reporting can be deleted. This is an irreversible process which will delete all reported data for this application.&lt;/p&gt; 
 *
 * @param id Application ID
 * @return void
 */
func (a DefaultApi) Delete_13(id Object) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete
 * &lt;p&gt;When applications are provided, this endpoint will remove those applications from the label.&lt;/p&gt;  &lt;p&gt;When no applications are provided, this endpoint will remove the label.&lt;/p&gt; 
 *
 * @param key Label key. Example: &#39;Language:Java&#39;
 * @return void
 */
func (a DefaultApi) Delete_14(key Object) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/labels/{key}.{format}"
	path = strings.Replace(path, "{"+"key"+"}", fmt.Sprintf("%v", key), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Delete
 * &lt;p&gt;This API endpoint deletes a server and all of its reported data.&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: Only servers that have stopped reporting can be deleted. This is an irreversible process which will delete all reported data for this server.&lt;/p&gt; 
 *
 * @param id Server ID
 * @return void
 */
func (a DefaultApi) Delete_15(id Object) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/servers/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: This is legacy alerting.  This endpoint will be deprecated.&lt;/p&gt;  &lt;p&gt;This API endpoint returns a paginated list of the alert policies associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;Alert policies can be filtered by their name, list of IDs, type (application, key_transaction, or server) or whether or not policies are archived (defaults to filtering archived policies).&lt;/p&gt; 
 *
 * @param filterName Filter by name
 * @param filterType Filter by policy types
 * @param filterIds Filter by policy IDs
 * @param filterEnabled Select only enabled/disabled policies (default: both)
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List(filterName Object, filterType []Object, filterIds []Object, filterEnabled Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alert_policies.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[name]", a.Configuration.APIClient.ParameterToString(filterName, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterType {
			queryParams.Add("filter[type]", value)
		}
	} else {
		queryParams.Add("filter[type]", a.Configuration.APIClient.ParameterToString(filterType, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("filter[enabled]", a.Configuration.APIClient.ParameterToString(filterEnabled, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint works with new Alerts on alerts.newrelic.com.&lt;/p&gt;  &lt;p&gt;It returns a list of the channels associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#channels-list\&quot;&gt;listing notification channels&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_16(page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_channels.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint allows you to list the alert events for your account.&lt;/p&gt;  &lt;p&gt;Alerts events can be filter by product, target type, group ID, instance ID, and event type.&lt;/p&gt;  &lt;p&gt;The options for products are: &lt;b&gt;APM&lt;/b&gt;, &lt;b&gt;BROWSER&lt;/b&gt;, &lt;b&gt;MOBILE&lt;/b&gt;, &lt;b&gt;SERVERS&lt;/b&gt;, &lt;b&gt;PLUGINS&lt;/b&gt;, &lt;b&gt;SYNTHETICS&lt;/b&gt;, and &lt;b&gt;ALERTS&lt;/b&gt;.&lt;/p&gt;  &lt;p&gt;The options for entity type are: &lt;b&gt;Application&lt;/b&gt;, &lt;b&gt;Server&lt;/b&gt;, &lt;b&gt;KeyTransaction&lt;/b&gt;, &lt;b&gt;Plugin&lt;/b&gt;, &lt;b&gt;MobileApplication&lt;/b&gt;, &lt;b&gt;BrowserApplication&lt;/b&gt;, and &lt;b&gt;Monitor&lt;/b&gt;.&lt;/p&gt;  &lt;p&gt;The options for event type are: &lt;b&gt;NOTIFICATION&lt;/b&gt;, &lt;b&gt;DEPLOYMENT&lt;/b&gt;, &lt;b&gt;VIOLATION_OPEN&lt;/b&gt;, &lt;b&gt;VIOLATION_CLOSE&lt;/b&gt;, &lt;b&gt;VIOLATION&lt;/b&gt;, and &lt;b&gt;INSTRUMENTATION&lt;/b&gt;.&lt;/p&gt;  &lt;p&gt;The group ID option is normally the same as the entity ID (e.g. an Application group ID and entity ID will be the same), however PLUGINS have a group ID representing the PLUGIN itself, and entity IDs for all instances of that PLUGIN type.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param filterProduct Filter by New Relic product
 * @param filterEntityType Filter by entity type
 * @param filterEntityGroupId Filter by entity group ID
 * @param filterEntityId Filter by entity ID
 * @param filterEventType Filter by event type
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_17(filterProduct Object, filterEntityType Object, filterEntityGroupId Object, filterEntityId Object, filterEventType Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_events.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[product]", a.Configuration.APIClient.ParameterToString(filterProduct, ""))
			queryParams.Add("filter[entity_type]", a.Configuration.APIClient.ParameterToString(filterEntityType, ""))
			queryParams.Add("filter[entity_group_id]", a.Configuration.APIClient.ParameterToString(filterEntityGroupId, ""))
			queryParams.Add("filter[entity_id]", a.Configuration.APIClient.ParameterToString(filterEntityId, ""))
			queryParams.Add("filter[event_type]", a.Configuration.APIClient.ParameterToString(filterEventType, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a list of the Browser Applications associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;Browser Applications can be filtered by their name, or by the application IDs.&lt;/p&gt; 
 *
 * @param filterName Filter by application name
 * @param filterIds Filter by application ids
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_18(filterName Object, filterIds []Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/browser_applications.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[name]", a.Configuration.APIClient.ParameterToString(filterName, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a list of the plugin components associated with your New Relic account. Plugins can be filtered by their name, the list of component IDs or a plugin ID. See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/get-individual-plugin-components-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt; listing components&lt;/a&gt; and &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param filterName Filter components by name
 * @param filterIds Filter components by ids
 * @param filterPluginId Filter components by the plugin
 * @param healthStatus Include component health status
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_19(filterName Object, filterIds []Object, filterPluginId Object, healthStatus Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/components.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[name]", a.Configuration.APIClient.ParameterToString(filterName, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("filter[plugin_id]", a.Configuration.APIClient.ParameterToString(filterPluginId, ""))
			queryParams.Add("health_status", a.Configuration.APIClient.ParameterToString(healthStatus, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt;paginated&lt;/a&gt;  list of the key transactions associated with your New Relic account.  The time range for summary data is the last 10 minutes.&lt;/p&gt;  &lt;p&gt;Key transactions can be filtered by their name or list of IDs.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion of  &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param filterName Filter by name
 * @param filterIds Filter by policy IDs
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_20(filterName Object, filterIds []Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/key_transactions.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[name]", a.Configuration.APIClient.ParameterToString(filterName, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt;paginated&lt;/a&gt; list of the labels available for the account.&lt;/p&gt; 
 *
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_21(page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/labels.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a list of the Mobile Applications associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;MobileApplications can be filtered by their name, or by the application IDs.&lt;/p&gt; 
 *
 * @return void
 */
func (a DefaultApi) List_22() (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/mobile_applications.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: This is legacy alerting.  This endpoint will be deprecated.&lt;/p&gt;  &lt;p&gt;This API endpoint returns a &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt;paginated&lt;/a&gt;  list of the notification channels associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;Notification channels can be filtered by their type or a list of IDs.&lt;/p&gt; 
 *
 * @param filterType Filter by notification channel types
 * @param filterIds Filter by notification channel IDs
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_23(filterType []Object, filterIds []Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/notification_channels.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterType {
			queryParams.Add("filter[type]", value)
		}
	} else {
		queryParams.Add("filter[type]", a.Configuration.APIClient.ParameterToString(filterType, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a list of the Plugins associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;Plugins can be filtered by their guid or the list of plugin IDs.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param filterGuid Filter plugin by guid
 * @param filterIds Filter plugin by ids
 * @param page Pagination index
 * @param detailed Include all data about a plugin
 * @return void
 */
func (a DefaultApi) List_24(filterGuid Object, filterIds []Object, page Object, detailed Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/plugins.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[guid]", a.Configuration.APIClient.ParameterToString(filterGuid, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
			queryParams.Add("detailed", a.Configuration.APIClient.ParameterToString(detailed, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt;paginated&lt;/a&gt; list of the Servers associated with your New Relic account. The time range for summary data is the last 10 minutes.&lt;/p&gt;  &lt;p&gt;Servers can be filtered by their name, hostname, or the list of server IDs.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion and examples of using &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-application-specific-server-host-instance-ids\&quot; target&#x3D;\&quot;_blank\&quot;&gt;filters&lt;/a&gt; and &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param filterName Filter by name
 * @param filterHost Filter by host
 * @param filterIds Filter by server IDs
 * @param filterLabels Filter by server labels (beta)
 * @param filterReported Filter by reported in last 10 hours
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_25(filterName Object, filterHost Object, filterIds []Object, filterLabels Object, filterReported Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/servers.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[name]", a.Configuration.APIClient.ParameterToString(filterName, ""))
			queryParams.Add("filter[host]", a.Configuration.APIClient.ParameterToString(filterHost, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("filter[labels]", a.Configuration.APIClient.ParameterToString(filterLabels, ""))
			queryParams.Add("filter[reported]", a.Configuration.APIClient.ParameterToString(filterReported, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;Show a list of usage for a product in a given time frame.&lt;/p&gt;  &lt;p&gt;NOTE: Currently you must request 1 month of data, or less, to retrieve daily usage. Requests for greater than 1 month will currently return only monthly usage.&lt;/p&gt; 
 *
 * @param product Available: apm, browser, mobile.
 * @param startDate Format: YYYY-MM-DD
 * @param endDate Format: YYYY-MM-DD
 * @param includeSubaccounts Include subaccounts usage? (default: false)
 * @return void
 */
func (a DefaultApi) List_26(product Object, startDate time.Time, endDate time.Time, includeSubaccounts Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/usages/{product}.{format}"
	path = strings.Replace(path, "{"+"product"+"}", fmt.Sprintf("%v", product), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("start_date", a.Configuration.APIClient.ParameterToString(startDate, ""))
			queryParams.Add("end_date", a.Configuration.APIClient.ParameterToString(endDate, ""))
			queryParams.Add("include_subaccounts", a.Configuration.APIClient.ParameterToString(includeSubaccounts, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;Show a &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt;paginated&lt;/a&gt; list of all users.&lt;/p&gt;  &lt;p&gt;Uers can be filtered by their ids or email.&lt;/p&gt; 
 *
 * @param filterIds Filter by user IDs
 * @param filterEmail Filter by user email
 * @param page 
 * @return void
 */
func (a DefaultApi) List_27(filterIds []Object, filterEmail Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/users.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("filter[email]", a.Configuration.APIClient.ParameterToString(filterEmail, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a list of the Incidents associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#incidents\&quot; target&#x3D;\&quot;_blank\&quot;&gt;listing incidents&lt;/a&gt;  and &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt;output pagination&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_28(page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_incidents.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint works with new Alerts on alerts.newrelic.com.&lt;/p&gt;  &lt;p&gt;This API endpoint returns a list of the alert policies associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param filterName Name (must be exact match)
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_29(filterName Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_policies.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[name]", a.Configuration.APIClient.ParameterToString(filterName, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint allows you to list the Synthetics conditions for your alert policy.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#synthetics-conditions-list\&quot; target&#x3D;\&quot;_blank\&quot;&gt;listing Synthetic conditions&lt;/a&gt; and &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param policyId Alerts policy ID
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_30(policyId Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_synthetics_conditions.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("policy_id", a.Configuration.APIClient.ParameterToString(policyId, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint works with new Alerts on alerts.newrelic.com.&lt;/p&gt;  &lt;p&gt;It returns a list of the violations associated with your New Relic account.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param page Pagination index
 * @param onlyOpen Filter by open violations
 * @return void
 */
func (a DefaultApi) List_31(page Object, onlyOpen Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_violations.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
			queryParams.Add("only_open", a.Configuration.APIClient.ParameterToString(onlyOpen, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt;paginated&lt;/a&gt; list of the Applications associated with your New Relic account. The time range for summary data is the last 10 minutes.&lt;/p&gt;  &lt;p&gt;Applications can be filtered by their name, hosts, the list of application IDs or the application language as reported by the agents.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion and examples of using &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-application-specific-server-host-instance-ids\&quot; target&#x3D;\&quot;_blank\&quot;&gt; filters &lt;/a&gt; and &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param filterName Filter by application name
 * @param filterHost Filter by application host
 * @param filterIds Filter by application ids
 * @param filterLanguage Filter by application language
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_32(filterName Object, filterHost Object, filterIds []Object, filterLanguage Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[name]", a.Configuration.APIClient.ParameterToString(filterName, ""))
			queryParams.Add("filter[host]", a.Configuration.APIClient.ParameterToString(filterHost, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("filter[language]", a.Configuration.APIClient.ParameterToString(filterLanguage, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a paginated list of the deployments associated with a given application.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot;&gt;output pagination&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param applicationId Application ID
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_33(applicationId Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/deployments.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; paginated&lt;/a&gt; list of hosts associated with the given application. The time range for summary data is the last 10 minutes.&lt;/p&gt;  &lt;p&gt;Application hosts can be filtered by hostname, or the list of application host IDs.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion and examples of using &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-application-specific-server-host-instance-ids\&quot; target&#x3D;\&quot;_blank\&quot;&gt; filters &lt;/a&gt; and &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param applicationId Application ID
 * @param filterHostname Filter by server hostname
 * @param filterIds Filter by application host ids
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_34(applicationId Object, filterHostname Object, filterIds []Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/hosts.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[hostname]", a.Configuration.APIClient.ParameterToString(filterHostname, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * List
 * &lt;p&gt;This API endpoint returns a &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; paginated&lt;/a&gt; list of instances associated with the given application. The time range for summary data is the last 10 minutes.&lt;/p&gt;  &lt;p&gt;Application instances can be filtered by hostname, or the list of application instance IDs.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion and examples of using &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-application-specific-server-host-instance-ids\&quot; target&#x3D;\&quot;_blank\&quot;&gt; filters &lt;/a&gt; and &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param applicationId Application ID
 * @param filterHostname Filter by server hostname
 * @param filterIds Filter by application instance ids
 * @param page Pagination index
 * @return void
 */
func (a DefaultApi) List_35(applicationId Object, filterHostname Object, filterIds []Object, page Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/instances.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("filter[hostname]", a.Configuration.APIClient.ParameterToString(filterHostname, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range filterIds {
			queryParams.Add("filter[ids]", value)
		}
	} else {
		queryParams.Add("filter[ids]", a.Configuration.APIClient.ParameterToString(filterIds, collectionFormat))
	}
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Data
 * &lt;p&gt;This API endpoint returns a list of values for each of the requested metrics. The list of available metrics can be returned using the Metric Name API endpoint.&lt;/p&gt;  &lt;p&gt;Metric data can be filtered by a number of parameters, including multiple names and values, and by time range. Metric names and values will be matched intelligently in the background.&lt;/p&gt;  &lt;p&gt;You can also retrieve a summarized data point across the entire time range selected by using the summarize parameter.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;, &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/extracting-metric-data\&quot; target&#x3D;\&quot;_blank\&quot;&gt; time range&lt;/a&gt;  related considerations, and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param applicationId Application ID
 * @param names Retrieve specific metrics by name
 * @param values Retrieve specific metric values
 * @param from Retrieve metrics after this time
 * @param to Retrieve metrics before this time
 * @param period Period of timeslices in seconds
 * @param summarize Summarize the data
 * @param raw Return unformatted raw values
 * @return void
 */
func (a DefaultApi) MetricData(applicationId Object, names []Object, values []Object, from Object, to Object, period Object, summarize Object, raw Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/metrics/data.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range names {
			queryParams.Add("names", value)
		}
	} else {
		queryParams.Add("names", a.Configuration.APIClient.ParameterToString(names, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range values {
			queryParams.Add("values", value)
		}
	} else {
		queryParams.Add("values", a.Configuration.APIClient.ParameterToString(values, collectionFormat))
	}
			queryParams.Add("from", a.Configuration.APIClient.ParameterToString(from, ""))
			queryParams.Add("to", a.Configuration.APIClient.ParameterToString(to, ""))
			queryParams.Add("period", a.Configuration.APIClient.ParameterToString(period, ""))
			queryParams.Add("summarize", a.Configuration.APIClient.ParameterToString(summarize, ""))
			queryParams.Add("raw", a.Configuration.APIClient.ParameterToString(raw, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Data
 * &lt;p&gt;This API endpoint returns a list of values for each of the requested metrics. The list of available metrics can be returned using the Metric Name API endpoint.&lt;/p&gt;  &lt;p&gt;Metric data can be filtered by a number of parameters, including multiple names and values, and by time range. Metric names and values will be matched intelligently in the background.&lt;/p&gt;  &lt;p&gt;You can also retrieve a summarized data point across the entire time range selected by using the summarize parameter.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt;, &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/extracting-metric-data\&quot; target&#x3D;\&quot;_blank\&quot;&gt; time range&lt;/a&gt;  related considerations, and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param mobileApplicationId Mobile application ID
 * @param names Retrieve specific metrics by name
 * @param values Retrieve specific metric values
 * @param from Retrieve metrics after this time
 * @param to Retrieve metrics before this time
 * @param period Period of timeslices in seconds
 * @param summarize Summarize the data
 * @param raw Return unformatted raw values
 * @return void
 */
func (a DefaultApi) MetricData_36(mobileApplicationId Object, names []Object, values []Object, from Object, to Object, period Object, summarize Object, raw Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/mobile_applications/{mobile_application_id}/metrics/data.{format}"
	path = strings.Replace(path, "{"+"mobile_application_id"+"}", fmt.Sprintf("%v", mobileApplicationId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range names {
			queryParams.Add("names", value)
		}
	} else {
		queryParams.Add("names", a.Configuration.APIClient.ParameterToString(names, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range values {
			queryParams.Add("values", value)
		}
	} else {
		queryParams.Add("values", a.Configuration.APIClient.ParameterToString(values, collectionFormat))
	}
			queryParams.Add("from", a.Configuration.APIClient.ParameterToString(from, ""))
			queryParams.Add("to", a.Configuration.APIClient.ParameterToString(to, ""))
			queryParams.Add("period", a.Configuration.APIClient.ParameterToString(period, ""))
			queryParams.Add("summarize", a.Configuration.APIClient.ParameterToString(summarize, ""))
			queryParams.Add("raw", a.Configuration.APIClient.ParameterToString(raw, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Names
 * &lt;p&gt;Return a list of known metrics and their value names for the given resource.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt; and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param applicationId Application ID
 * @param name Filter metrics by name
 * @param page Pagination index (will be deprecated)
 * @param cursor Cursor for next page (replacing page param)
 * @return void
 */
func (a DefaultApi) MetricNames(applicationId Object, name Object, page Object, cursor Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/metrics.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("name", a.Configuration.APIClient.ParameterToString(name, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
			queryParams.Add("cursor", a.Configuration.APIClient.ParameterToString(cursor, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Names
 * &lt;p&gt;Return a list of known metrics and their value names for the given resource.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt; and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param mobileApplicationId Mobile application ID
 * @param name Filter metrics by name
 * @param page Pagination index (will be deprecated)
 * @param cursor Cursor for next page (replacing page param)
 * @return void
 */
func (a DefaultApi) MetricNames_37(mobileApplicationId Object, name Object, page Object, cursor Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/mobile_applications/{mobile_application_id}/metrics.{format}"
	path = strings.Replace(path, "{"+"mobile_application_id"+"}", fmt.Sprintf("%v", mobileApplicationId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("name", a.Configuration.APIClient.ParameterToString(name, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
			queryParams.Add("cursor", a.Configuration.APIClient.ParameterToString(cursor, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Names
 * &lt;p&gt;Return a list of known metrics and their value names for the given resource.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt; and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param applicationId Application ID
 * @param hostId Application Host ID
 * @param name Filter metrics by name
 * @param page Pagination index (will be deprecated)
 * @param cursor Cursor for next page (replacing page param)
 * @return void
 */
func (a DefaultApi) Names(applicationId Object, hostId Object, name Object, page Object, cursor Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/hosts/{host_id}/metrics.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)
	path = strings.Replace(path, "{"+"host_id"+"}", fmt.Sprintf("%v", hostId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("name", a.Configuration.APIClient.ParameterToString(name, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
			queryParams.Add("cursor", a.Configuration.APIClient.ParameterToString(cursor, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Names
 * &lt;p&gt;Return a list of known metrics and their value names for the given resource.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt; and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param applicationId Application ID
 * @param instanceId Application Instance ID
 * @param name Filter metrics by name
 * @param page Pagination index (will be deprecated)
 * @param cursor Cursor for next page (replacing page param)
 * @return void
 */
func (a DefaultApi) Names_38(applicationId Object, instanceId Object, name Object, page Object, cursor Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/instances/{instance_id}/metrics.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)
	path = strings.Replace(path, "{"+"instance_id"+"}", fmt.Sprintf("%v", instanceId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("name", a.Configuration.APIClient.ParameterToString(name, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
			queryParams.Add("cursor", a.Configuration.APIClient.ParameterToString(cursor, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Names
 * &lt;p&gt;Return a list of known metrics and their value names for the given resource.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt; and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param componentId Component ID
 * @param name Filter metrics by name
 * @param page Pagination index (will be deprecated)
 * @param cursor Cursor for next page (replacing page param)
 * @return void
 */
func (a DefaultApi) Names_39(componentId Object, name Object, page Object, cursor Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/components/{component_id}/metrics.{format}"
	path = strings.Replace(path, "{"+"component_id"+"}", fmt.Sprintf("%v", componentId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("name", a.Configuration.APIClient.ParameterToString(name, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
			queryParams.Add("cursor", a.Configuration.APIClient.ParameterToString(cursor, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Metric Names
 * &lt;p&gt;Return a list of known metrics and their value names for the given resource.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/pagination-api-output\&quot; target&#x3D;\&quot;_blank\&quot;&gt; output pagination&lt;/a&gt; and for examples of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/new-relic-rest-api-v2-getting-started#examples\&quot; target&#x3D;\&quot;_blank\&quot;&gt;requesting and using metric values&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param serverId Server ID
 * @param name Filter metrics by name
 * @param page Pagination index (will be deprecated)
 * @param cursor Cursor for next page (replacing page param)
 * @return void
 */
func (a DefaultApi) Names_40(serverId Object, name Object, page Object, cursor Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/servers/{server_id}/metrics.{format}"
	path = strings.Replace(path, "{"+"server_id"+"}", fmt.Sprintf("%v", serverId), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("name", a.Configuration.APIClient.ParameterToString(name, ""))
			queryParams.Add("page", a.Configuration.APIClient.ParameterToString(page, ""))
			queryParams.Add("cursor", a.Configuration.APIClient.ParameterToString(cursor, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Reset password
 * &lt;p&gt;This API endpoints reset the user password, identified by ID&lt;/p&gt; 
 *
 * @param id User ID
 * @return void
 */
func (a DefaultApi) ResetPassword(id Object) (*APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/users/{id}/reset_password.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: This is legacy alerting.  This endpoint will be deprecated.&lt;/p&gt;  &lt;p&gt;This API endpoint returns a single alert policy, identified by ID.”&lt;/p&gt; 
 *
 * @param id Alert policy ID
 * @return void
 */
func (a DefaultApi) Show(id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alert_policies/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;This API endpoint returns a single application host, identified by ID. The time range for summary data is the last 10 minutes.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param applicationId Application ID
 * @param id Application host ID
 * @return void
 */
func (a DefaultApi) Show_41(applicationId Object, id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/hosts/{id}.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;This API endpoint returns a single application instance, identified by ID. The time range for summary data is the last 10 minutes.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion of  &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param applicationId Application ID
 * @param id Application instance ID
 * @return void
 */
func (a DefaultApi) Show_42(applicationId Object, id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{application_id}/instances/{id}.{format}"
	path = strings.Replace(path, "{"+"application_id"+"}", fmt.Sprintf("%v", applicationId), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;This API endpoint returns a single Application, identified by ID. The time range for summary data is the last 10 minutes.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion of the &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt; summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param id Application ID
 * @return void
 */
func (a DefaultApi) Show_43(id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;This API endpoint returns a single component, identified by its ID. See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/get-individual-plugin-components-v2#list_component_id\&quot; target&#x3D;\&quot;blank\&quot;&gt;listing components by ID&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param id Plugin ID
 * @return void
 */
func (a DefaultApi) Show_44(id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/components/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;This endpoint returns a single key transaction, identified by ID. The time range for summary data is the last 10 minutes.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion of  &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param id Key transaction ID
 * @return void
 */
func (a DefaultApi) Show_45(id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/key_transactions/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;This API endpoint returns a single Mobile Application, identified by ID. The time range for summary data is the last 30 minutes.&lt;/p&gt; 
 *
 * @param id Mobile Application ID
 * @return void
 */
func (a DefaultApi) Show_46(id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/mobile_applications/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: This is legacy alerting.  This endpoint will be deprecated.&lt;/p&gt;  &lt;p&gt;This API endpoint returns a single notification channel, identified by ID.”&lt;/p&gt; 
 *
 * @param id Notification Channel ID
 * @return void
 */
func (a DefaultApi) Show_47(id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/notification_channels/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;This API endpoint returns a single plugin, identified by its ID.&lt;/p&gt; 
 *
 * @param id Plugin ID
 * @param detailed Include all data about a plugin
 * @return void
 */
func (a DefaultApi) Show_48(id Object, detailed Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/plugins/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("detailed", a.Configuration.APIClient.ParameterToString(detailed, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;This API endpoint returns a single Server, identified by ID. The time range for summary data is the last 10 minutes.”&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt;summary data output&lt;/a&gt;.&lt;/p&gt;  
 *
 * @param id Server ID
 * @return void
 */
func (a DefaultApi) Show_49(id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/servers/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Show
 * &lt;p&gt;This API endpoint returns a single user, identified by ID.&lt;/p&gt; 
 *
 * @param id User ID
 * @return void
 */
func (a DefaultApi) Show_50(id Object) (*APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/users/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Update
 * &lt;p&gt;This is legacy alerting.  This endpoint will be deprecated.&lt;/p&gt;  &lt;p&gt;This API endpoint allows you to update your alert policies.&lt;/p&gt;  &lt;p&gt;The input is expected to be in &lt;strong&gt;JSON or XML&lt;/strong&gt; format in the body parameters of the PUT request. The exact schema is defined below. Any extra parameters passed in the body &lt;strong&gt;will be ignored&lt;/strong&gt;.&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; When updating alertable and notification channel links, the list sent replaces the existing list. Invalid values will be ignored but an empty array will result in alertables/channels being reset.&lt;/p&gt; 
 *
 * @param id Alert policy ID
 * @param alertPolicy Alert policy schema
 * @return void
 */
func (a DefaultApi) Update(id Object, alertPolicy AlertPolicy) (*APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alert_policies/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &alertPolicy


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Update
 * &lt;p&gt;This API endpoint updates policy/channel associations.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#policy-channels-update\&quot;&gt;updating notification channels with policies&lt;/a&gt;.&lt;/p&gt; 
 *
 * @param policyId Policy ID
 * @param channelIds Channel IDs
 * @return void
 */
func (a DefaultApi) Update_51(policyId Object, channelIds []Object) (*APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_policy_channels.{format}"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("policy_id", a.Configuration.APIClient.ParameterToString(policyId, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range channelIds {
			queryParams.Add("channel_ids", value)
		}
	} else {
		queryParams.Add("channel_ids", a.Configuration.APIClient.ParameterToString(channelIds, collectionFormat))
	}
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Update
 * &lt;p&gt;This API endpoint allows you to update Synthetics conditions for your alert policies.&lt;/p&gt;  &lt;p&gt;Note: &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/rest-api-key\&quot;&gt;Admin User’s API Key&lt;/a&gt; is required.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion on &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/alerts/new-relic-alerts/rest-api-alerts/rest-api-calls-new-relic-alerts#synthetics-conditions-update\&quot; target&#x3D;\&quot;_blank\&quot;&gt;updating Synthetic conditions&lt;/a&gt;.&lt;/p&gt;  &lt;p&gt;See Alerts Synthetics Conditions &amp;gt; Create for an explanation of the field values used in this command.&lt;/p&gt; 
 *
 * @param id Alerts condition ID to update
 * @param syntheticsCondition Condition schema
 * @return void
 */
func (a DefaultApi) Update_52(id Object, syntheticsCondition SyntheticsCondition) (*APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/alerts_synthetics_conditions/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &syntheticsCondition


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Update
 * &lt;p&gt;This API endpoint allows you to update certain parameters of your application.&lt;/p&gt;  &lt;p&gt;The input is expected to be in &lt;strong&gt;JSON or XML&lt;/strong&gt; format in the body parameter of the PUT request. The exact schema is defined below. Any extra parameters passed in the body &lt;strong&gt;will be ignored&lt;/strong&gt;.&lt;/p&gt;  &lt;p&gt;See our documentation for a discussion and simple example of &lt;a href&#x3D;\&quot;https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/changing-alias-your-application-v2\&quot; target&#x3D;\&quot;_blank\&quot;&gt; updating&lt;/a&gt; an application.&lt;/p&gt;  
 *
 * @param id Application ID
 * @param application Application schema
 * @return void
 */
func (a DefaultApi) Update_53(id Object, application Application) (*APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/applications/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &application


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Update
 * &lt;p&gt;This API endpoint allows you to rename your server.&lt;/p&gt;  &lt;p&gt;The input is expected to be in &lt;strong&gt;JSON or XML&lt;/strong&gt; format in the body parameter of the PUT request. The exact schema is defined below. Any extra parameters passed in the body &lt;strong&gt;will be ignored&lt;/strong&gt;.&lt;/p&gt; 
 *
 * @param id Server ID
 * @param server New name of the server
 * @return void
 */
func (a DefaultApi) Update_54(id Object, server Server) (*APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/v2/servers/{id}.{format}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &server


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

